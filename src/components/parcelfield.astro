<div id="parcelfield" class="absolute inset-0">
  <canvas id="parcelfield-canvas"></canvas>

  <script>
    import invariant from "tiny-invariant";

    const COUNT = 4;
    const SPEED = 0.1;

    class Parcel {
      x: number;
      y: number;
      z: number;
      xPrev: number;
      yPrev: number;
      image: HTMLImageElement;

      constructor(x = 0, y = 0, z = 0, image: HTMLImageElement) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.xPrev = x;
        this.yPrev = y;
        this.image = image;
      }

      update(canvasWidth: number, canvasHeight: number, speed: number) {
        this.xPrev = this.x;
        this.yPrev = this.y;
        this.z += speed * 0.0675;
        this.x += this.x * (speed * 0.0225) * this.z;
        this.y += this.y * (speed * 0.0225) * this.z;
        if (
          this.x > canvasWidth / 2 ||
          this.x < -canvasWidth / 2 ||
          this.y > canvasHeight / 2 ||
          this.y < -canvasHeight / 2
        ) {
          this.x = Math.random() * canvasWidth - canvasWidth / 2;
          this.y = Math.random() * canvasHeight - canvasHeight / 2;
          this.xPrev = this.x;
          this.yPrev = this.y;
          this.z = 0;
        }
      }

      draw(ctx: CanvasRenderingContext2D) {
        // const size = this.z * 0.5 + 0.5; // Adjust size based on z-position
        const size = this.image.width;
        ctx.globalAlpha = this.z * 0.5 + 0.5; // Adjust opacity based on z-position
        console.log(
          `draw(${this.x - size / 2}, ${this.y - size / 2}, ${size}, ${size})`
        );
        ctx.drawImage(
          this.image,
          this.x - size / 2,
          this.y - size / 2,
          size,
          size
        );
        ctx.globalAlpha = 1;
      }
    }

    // In your setup function:
    const parcelImages = [
      "/03_ParcelPixelArt2-Small_0.png",
      "/03_ParcelPixelArt2-Small_1.png",
      "/03_ParcelPixelArt2-Small_2.png",
      "/03_ParcelPixelArt2-Small_3.png",
    ].map((src) => {
      const img = new Image();
      img.src = src;
      return img;
    });

    const parcels = Array.from(
      { length: COUNT },
      () =>
        new Parcel(
          0,
          0,
          0,
          parcelImages[Math.floor(Math.random() * parcelImages.length)]
        )
    );
    let rafId = 0;

    const canvas = document.querySelector(
      "#parcelfield-canvas"
    ) as HTMLCanvasElement;
    invariant(canvas, "canvas should not be null");
    const ctx = canvas.getContext("2d");

    const container = document.querySelector("#parcelfield") as HTMLElement;
    invariant(container, "container should not be null");
    const resizeObserver = new ResizeObserver(setup);
    resizeObserver.observe(container);

    function setup() {
      console.log("setup");
      invariant(ctx, "canvas context should not be null");
      rafId > 0 && cancelAnimationFrame(rafId);

      const { clientWidth: width, clientHeight: height } = container;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      ctx.scale(dpr, dpr);

      for (const parcel of parcels) {
        parcel.x = Math.random() * width - width / 2;
        parcel.y = Math.random() * height - height / 2;
        parcel.z = 0;
        // console.log(parcel);
      }

      ctx.translate(width / 2, height / 2);
      ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
      ctx.strokeStyle = "white";
      rafId = requestAnimationFrame(frame);
    }

    function frame() {
      // console.log("frame");
      invariant(ctx, "canvas context should not be null");
      const { clientWidth: width, clientHeight: height } = container;

      for (const parcel of parcels) {
        parcel.update(width, height, SPEED);
        parcel.draw(ctx);
        // console.log(parcel);
      }

      ctx.fillRect(-width / 2, -height / 2, width, height);
      rafId = requestAnimationFrame(frame);
    }
  </script>
</div>
